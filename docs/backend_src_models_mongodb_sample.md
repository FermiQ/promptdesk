# Documentation for `backend/src/models/mongodb/sample.ts`

## Overview

This module defines the Mongoose schema and the `Sample` class for managing "samples" in MongoDB. Samples represent concrete examples of inputs (`variables`, `prompt`) and their corresponding outputs (`result`) for a given prompt configuration. This is often used in prompt engineering workflows for testing, evaluation, and fine-tuning AI model responses. The module features a hashing mechanism to uniquely identify samples by their input variables and provides functionalities for recording (upserting), retrieving, updating (patching status and sort order), and deleting these samples.

## Key Components

1.  **Imports**:
    *   `mongoose`: The core Mongoose library for ODM with MongoDB.
    *   `crypto`: Node.js built-in module for cryptographic hashing (SHA256 in this case).
    *   `canonical_json_stringify` from `../../utils/canonicalJson`: A utility function to produce a standardized JSON string representation of an object. This ensures that the hash generated from the `variables` object is consistent, even if the order of keys within the object changes.

2.  **Mongoose Schema Definition (`schema`)**:
    *   This defines the structure for documents stored in the "samples" collection.
    *   **Fields**:
        *   `variables`: `mongoose.Schema.Types.Mixed` - Stores the input variables used for this specific sample instance (e.g., `{"customer_name": "Alice", "product": "WidgetMax"}`).
        *   `prompt`: `mongoose.Schema.Types.Mixed` - Stores the actual prompt text or structure that was used, potentially after variable substitution.
        *   `result`: `String` - The output or result generated by the AI model for this sample.
        *   `hash`: `String` - A SHA256 hash generated from the canonical JSON string of the `variables`. This hash, in combination with `prompt_id` and `organization_id`, uniquely identifies a sample based on its inputs.
        *   `status`: `String` - The current status of the sample (e.g., "new", "in_review", "approved", "rejected"), likely part of a review workflow.
        *   `sort_order`: `Number` - A numerical value used for sorting samples, often derived from their `status`.
        *   `prompt_id`: `String` - An identifier linking this sample to a specific prompt configuration (defined in the "prompts" or "promptxes" collection).
        *   `organization_id`: `String` - An identifier that scopes this sample to a specific organization.
    *   **Options**:
        *   `timestamps: true`: Automatically adds `createdAt` and `updatedAt` Mongoose-managed timestamps to each document.
    *   **Indexes**:
        *   `{ organization_id: 1, prompt_id: 1, hash: 1 }, { unique: true }`: A unique compound index. This prevents duplicate samples for the same organization, prompt, and input variables (as determined by the `hash`).
        *   `{ organization_id: 1, prompt_id: 1, sort_order: 1, createdAt: 1 }`: A compound index to optimize queries involving filtering by organization and prompt, and sorting by `sort_order` then by creation time.

3.  **`sampleSchema` (Mongoose Model)**:
    *   The Mongoose model compiled from the `schema` definition, named "Sample". The corresponding MongoDB collection will be "samples".

4.  **`Sample` Class**:
    This class provides methods for interacting with the `sampleSchema`.
    *   `async recordSampleDataIfNeeded(variables: any, prompt: any, result: string, prompt_id: string, organization_id: string)`:
        *   Generates a SHA256 `hash` from the `variables` using `canonical_json_stringify` for consistency.
        *   Constructs a `newSample` object. It attempts to extract `result.content` if `result` is an object, otherwise uses the `result` string directly.
        *   Performs an "upsert" operation using `findOneAndUpdate` with `{ upsert: true }` and `$setOnInsert`. This means:
            *   If a sample with the same `hash`, `prompt_id`, and `organization_id` already exists, nothing happens (the existing sample is not updated by this method).
            *   If no such sample exists, the `newSample` data is inserted.
    *   `async getSamples(page: any, limit = 10, organization_id: string, prompt_id: string)`:
        *   Retrieves a paginated list of samples for a given `organization_id` and `prompt_id`.
        *   Sorts the samples primarily by `sort_order` (ascending) and secondarily by `createdAt` (descending) to show the most recent items first within each sort order group.
        *   Returns a structured object containing pagination details (`page`, `per_page`, `total`, `total_pages`) and the `data` (list of transformed sample objects).
    *   `async patchSample(sample_id: string, changes: any, organization_id: string)`:
        *   Updates fields of an existing sample identified by `sample_id` and `organization_id`.
        *   It includes specific logic to automatically adjust `sort_order` based on the new `status`:
            *   "new" status sets `sort_order` to 0.
            *   "in_review" status sets `sort_order` to 1.
            *   "approved" status sets `sort_order` to 2.
            *   "rejected" status sets `sort_order` to 3.
    *   `async deleteSample(id: any, organization_id: string)`: Deletes a sample document by its `_id` and `organization_id`. Returns the `id` of the deleted sample.
    *   `transformSample(sample: any)`: A utility method that converts a Mongoose sample document into a plain JavaScript object and renames `_id` to `id`.

5.  **Exports**:
    *   The module exports both the `Sample` class and the `sampleSchema` (Mongoose model).

## Important Variables/Constants

*   `sampleSchema`: The compiled Mongoose model for the "Sample" collection.
*   The `Sample` class: The primary interface for managing sample data.

## Usage Examples

**Recording a new prompt interaction as a sample:**
```typescript
import { Sample } from './sample'; // Adjust path as necessary

const sampleManager = new Sample();
const orgId = "org_gamma_delta";
const promptIdForSummarization = "prompt_sum_001";

const inputVars = { text_to_summarize: "This is a very long document...", max_length: 100 };
const promptUsed = "Summarize the following text within {{max_length}} words: {{text_to_summarize}}";
const modelOutput = "This is a short summary.";

async function logSample() {
  try {
    await sampleManager.recordSampleDataIfNeeded(inputVars, promptUsed, modelOutput, promptIdForSummarization, orgId);
    console.log("Sample recorded (if new).");
  } catch (error) {
    console.error("Failed to record sample:", error);
  }
}
```

**Retrieving and reviewing samples:**
```typescript
async function reviewSamples(orgId: string, promptId: string, pageNum: number) {
  try {
    const results = await sampleManager.getSamples(pageNum, 5, orgId, promptId);
    console.log(`Displaying page ${results.page} of ${results.total_pages} for prompt ${promptId}`);
    results.data.forEach(sample => {
      console.log(`Sample ID: ${sample.id}, Status: ${sample.status}, Result: ${sample.result}`);
      // Potentially update status after review
      // await sampleManager.patchSample(sample.id, { status: "approved" }, orgId);
    });
  } catch (error) {
    console.error("Failed to retrieve samples:", error);
  }
}
```

## Dependencies and Interactions

*   **Mongoose**: The core ODM for all MongoDB interactions.
*   `crypto` (Node.js module): Used for generating SHA256 hashes for sample identification.
*   `../../utils/canonicalJson` (`canonical_json_stringify`): Essential for ensuring that the hashes of `variables` are consistent and reliable, which underpins the unique identification of samples.
*   **MongoDB Database**: All sample data is stored in and retrieved from a MongoDB collection named "samples". The defined indexes are crucial for performance and data integrity (preventing exact duplicates).
*   **Prompt Configurations**: Samples are intrinsically linked to prompt configurations (likely stored in a "prompts" or "promptxes" collection) via the `prompt_id` field.
*   **Organization Context (`organization_id`)**: Operations are scoped by `organization_id`, making the system suitable for multi-tenant use.

**Key Design Aspects**:
*   **Content-Addressable Samples**: The use of a hash derived from `variables` makes samples content-addressable for a given prompt. This is effective for de-duplication.
*   **Upsert with `$setOnInsert`**: The `recordSampleDataIfNeeded` method's use of upsert with `$setOnInsert` ensures that only new, unique samples (based on hash and prompt) are added, without modifying existing ones.
*   **Status-Driven Sorting**: The `patchSample` method's logic to tie `sort_order` to `status` indicates a workflow where samples are reviewed and categorized, and this categorization affects their display order.
```
